// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "msg.proto" (package "msg", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message msg.FrontendMessage
 */
export interface FrontendMessage {
    /**
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string; // agent id
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "shellOutput";
        /**
         * @generated from protobuf field: msg.ShellOutputMessage shell_output = 10;
         */
        shellOutput: ShellOutputMessage;
    } | {
        oneofKind: "shellError";
        /**
         * @generated from protobuf field: msg.ShellErrorMessage shell_error = 11;
         */
        shellError: ShellErrorMessage;
    } | {
        oneofKind: "shellConnect";
        /**
         * @generated from protobuf field: msg.ShellConnectMessage shell_connect = 50;
         */
        shellConnect: ShellConnectMessage;
    } | {
        oneofKind: "shellInput";
        /**
         * @generated from protobuf field: msg.ShellInputMessage shell_input = 51;
         */
        shellInput: ShellInputMessage;
    } | {
        oneofKind: "shellResize";
        /**
         * @generated from protobuf field: msg.ShellResizeMessage shell_resize = 52;
         */
        shellResize: ShellResizeMessage;
    } | {
        oneofKind: "shellDisconnect";
        /**
         * @generated from protobuf field: msg.ShellDisconnectMessage shell_disconnect = 53;
         */
        shellDisconnect: ShellDisconnectMessage;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message msg.ShellOutputMessage
 */
export interface ShellOutputMessage {
    /**
     * @generated from protobuf field: optional string token = 1;
     */
    token?: string; // shell token
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array; // output data
}
/**
 * @generated from protobuf message msg.ShellErrorMessage
 */
export interface ShellErrorMessage {
    /**
     * @generated from protobuf field: optional string token = 1;
     */
    token?: string; // shell token
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string; // error
}
/**
 * @generated from protobuf message msg.ShellConnectMessage
 */
export interface ShellConnectMessage {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string; // shell token
    /**
     * @generated from protobuf field: string cmd = 2;
     */
    cmd: string; // exe cmd
    /**
     * @generated from protobuf field: uint32 rows = 3;
     */
    rows: number; // row
    /**
     * @generated from protobuf field: uint32 cols = 4;
     */
    cols: number; // col
}
/**
 * @generated from protobuf message msg.ShellInputMessage
 */
export interface ShellInputMessage {
    /**
     * @generated from protobuf field: optional string token = 1;
     */
    token?: string; // shell token
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array; // input data
}
/**
 * @generated from protobuf message msg.ShellResizeMessage
 */
export interface ShellResizeMessage {
    /**
     * @generated from protobuf field: optional string token = 1;
     */
    token?: string; // shell token
    /**
     * @generated from protobuf field: uint32 rows = 2;
     */
    rows: number; // row
    /**
     * @generated from protobuf field: uint32 cols = 3;
     */
    cols: number; // col
}
/**
 * @generated from protobuf message msg.ShellDisconnectMessage
 */
export interface ShellDisconnectMessage {
    /**
     * @generated from protobuf field: optional string token = 1;
     */
    token?: string; // shell token
}
// @generated message type with reflection information, may provide speed optimized methods
class FrontendMessage$Type extends MessageType<FrontendMessage> {
    constructor() {
        super("msg.FrontendMessage", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "shell_output", kind: "message", oneof: "data", T: () => ShellOutputMessage },
            { no: 11, name: "shell_error", kind: "message", oneof: "data", T: () => ShellErrorMessage },
            { no: 50, name: "shell_connect", kind: "message", oneof: "data", T: () => ShellConnectMessage },
            { no: 51, name: "shell_input", kind: "message", oneof: "data", T: () => ShellInputMessage },
            { no: 52, name: "shell_resize", kind: "message", oneof: "data", T: () => ShellResizeMessage },
            { no: 53, name: "shell_disconnect", kind: "message", oneof: "data", T: () => ShellDisconnectMessage }
        ]);
    }
    create(value?: PartialMessage<FrontendMessage>): FrontendMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<FrontendMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrontendMessage): FrontendMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* msg.ShellOutputMessage shell_output */ 10:
                    message.data = {
                        oneofKind: "shellOutput",
                        shellOutput: ShellOutputMessage.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).shellOutput)
                    };
                    break;
                case /* msg.ShellErrorMessage shell_error */ 11:
                    message.data = {
                        oneofKind: "shellError",
                        shellError: ShellErrorMessage.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).shellError)
                    };
                    break;
                case /* msg.ShellConnectMessage shell_connect */ 50:
                    message.data = {
                        oneofKind: "shellConnect",
                        shellConnect: ShellConnectMessage.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).shellConnect)
                    };
                    break;
                case /* msg.ShellInputMessage shell_input */ 51:
                    message.data = {
                        oneofKind: "shellInput",
                        shellInput: ShellInputMessage.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).shellInput)
                    };
                    break;
                case /* msg.ShellResizeMessage shell_resize */ 52:
                    message.data = {
                        oneofKind: "shellResize",
                        shellResize: ShellResizeMessage.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).shellResize)
                    };
                    break;
                case /* msg.ShellDisconnectMessage shell_disconnect */ 53:
                    message.data = {
                        oneofKind: "shellDisconnect",
                        shellDisconnect: ShellDisconnectMessage.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).shellDisconnect)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrontendMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* msg.ShellOutputMessage shell_output = 10; */
        if (message.data.oneofKind === "shellOutput")
            ShellOutputMessage.internalBinaryWrite(message.data.shellOutput, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* msg.ShellErrorMessage shell_error = 11; */
        if (message.data.oneofKind === "shellError")
            ShellErrorMessage.internalBinaryWrite(message.data.shellError, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* msg.ShellConnectMessage shell_connect = 50; */
        if (message.data.oneofKind === "shellConnect")
            ShellConnectMessage.internalBinaryWrite(message.data.shellConnect, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* msg.ShellInputMessage shell_input = 51; */
        if (message.data.oneofKind === "shellInput")
            ShellInputMessage.internalBinaryWrite(message.data.shellInput, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* msg.ShellResizeMessage shell_resize = 52; */
        if (message.data.oneofKind === "shellResize")
            ShellResizeMessage.internalBinaryWrite(message.data.shellResize, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* msg.ShellDisconnectMessage shell_disconnect = 53; */
        if (message.data.oneofKind === "shellDisconnect")
            ShellDisconnectMessage.internalBinaryWrite(message.data.shellDisconnect, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message msg.FrontendMessage
 */
export const FrontendMessage = new FrontendMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShellOutputMessage$Type extends MessageType<ShellOutputMessage> {
    constructor() {
        super("msg.ShellOutputMessage", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ShellOutputMessage>): ShellOutputMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ShellOutputMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShellOutputMessage): ShellOutputMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token */ 1:
                    message.token = reader.string();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShellOutputMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message msg.ShellOutputMessage
 */
export const ShellOutputMessage = new ShellOutputMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShellErrorMessage$Type extends MessageType<ShellErrorMessage> {
    constructor() {
        super("msg.ShellErrorMessage", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShellErrorMessage>): ShellErrorMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ShellErrorMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShellErrorMessage): ShellErrorMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShellErrorMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message msg.ShellErrorMessage
 */
export const ShellErrorMessage = new ShellErrorMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShellConnectMessage$Type extends MessageType<ShellConnectMessage> {
    constructor() {
        super("msg.ShellConnectMessage", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cmd", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "rows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cols", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShellConnectMessage>): ShellConnectMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.cmd = "";
        message.rows = 0;
        message.cols = 0;
        if (value !== undefined)
            reflectionMergePartial<ShellConnectMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShellConnectMessage): ShellConnectMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string cmd */ 2:
                    message.cmd = reader.string();
                    break;
                case /* uint32 rows */ 3:
                    message.rows = reader.uint32();
                    break;
                case /* uint32 cols */ 4:
                    message.cols = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShellConnectMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string cmd = 2; */
        if (message.cmd !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cmd);
        /* uint32 rows = 3; */
        if (message.rows !== 0)
            writer.tag(3, WireType.Varint).uint32(message.rows);
        /* uint32 cols = 4; */
        if (message.cols !== 0)
            writer.tag(4, WireType.Varint).uint32(message.cols);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message msg.ShellConnectMessage
 */
export const ShellConnectMessage = new ShellConnectMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShellInputMessage$Type extends MessageType<ShellInputMessage> {
    constructor() {
        super("msg.ShellInputMessage", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ShellInputMessage>): ShellInputMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ShellInputMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShellInputMessage): ShellInputMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token */ 1:
                    message.token = reader.string();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShellInputMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message msg.ShellInputMessage
 */
export const ShellInputMessage = new ShellInputMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShellResizeMessage$Type extends MessageType<ShellResizeMessage> {
    constructor() {
        super("msg.ShellResizeMessage", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cols", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShellResizeMessage>): ShellResizeMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rows = 0;
        message.cols = 0;
        if (value !== undefined)
            reflectionMergePartial<ShellResizeMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShellResizeMessage): ShellResizeMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token */ 1:
                    message.token = reader.string();
                    break;
                case /* uint32 rows */ 2:
                    message.rows = reader.uint32();
                    break;
                case /* uint32 cols */ 3:
                    message.cols = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShellResizeMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* uint32 rows = 2; */
        if (message.rows !== 0)
            writer.tag(2, WireType.Varint).uint32(message.rows);
        /* uint32 cols = 3; */
        if (message.cols !== 0)
            writer.tag(3, WireType.Varint).uint32(message.cols);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message msg.ShellResizeMessage
 */
export const ShellResizeMessage = new ShellResizeMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShellDisconnectMessage$Type extends MessageType<ShellDisconnectMessage> {
    constructor() {
        super("msg.ShellDisconnectMessage", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShellDisconnectMessage>): ShellDisconnectMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ShellDisconnectMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShellDisconnectMessage): ShellDisconnectMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShellDisconnectMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message msg.ShellDisconnectMessage
 */
export const ShellDisconnectMessage = new ShellDisconnectMessage$Type();
